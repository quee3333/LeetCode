思路
本题要求计算整数数组中的最大连续子数组和。使用动态规划的思想，核心是维护一个变量pre，表示以当前元素结尾的最大子数组和。遍历数组时，对于每个元素：

如果pre（前一个位置的最大子数组和）大于0，则加上当前元素（因为正数会增大总和）。

如果pre小于等于0，则放弃前面的部分，从当前元素重新开始（因为负数会拉低总和）。
同时，用变量ans记录遍历过程中出现的最大子数组和，最终返回ans。

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = nums[0], ans = nums[0];  // 初始化：pre表示以第0个元素结尾的最大子数组和，ans记录全局最大值
        for (int i = 1; i < nums.size(); i++) {  // 从第1个元素开始遍历
            pre = pre > 0 ? pre + nums[i] : nums[i];  // 如果pre>0，则加上当前元素；否则从当前元素重新开始
            ans = max(ans, pre);  // 更新全局最大值
        }
        return ans;  // 返回最大子数组和
    }
};

初始化：

pre = nums[0]：以第一个元素结尾的子数组和只能是nums[0]。

ans = nums[0]：初始时最大子数组和就是第一个元素。

遍历数组（从索引1开始）：

更新pre：

如果pre > 0：说明前面的子数组和是正收益，加上当前元素nums[i]可能使和更大，所以pre = pre + nums[i]。

如果pre <= 0：前面的子数组和是负收益，直接放弃，从当前元素重新开始，所以pre = nums[i]。

更新ans：每一步都检查pre是否刷新了最大和，即ans = max(ans, pre)。

返回结果：遍历结束后，ans即为最大子数组和。
