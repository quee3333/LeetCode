核心思想是使用贪心策略，
通过维护一个当前能够到达的最远位置（maxPos）来避免重复计算和回溯。遍历数组时，如果当前位置在可达范围内（i <= maxPos）
，则更新最远位置；若当前位置不可达（i > maxPos），则无法继续前进，直接返回失败。



class Solution {
public:
    bool canJump(vector<int>& nums) {
        // 初始化：i为当前遍历位置，maxPos为当前能到达的最远位置（初始为0）
        for (int i = 0, maxPos = 0; i < nums.size(); i++) {
            // 如果当前位置i已经超过之前计算的最远位置maxPos
            // 说明无法到达i，更无法到达终点，返回false
            if (i > maxPos)
                return false;
            
            // 更新maxPos：比较当前maxPos和从位置i能跳到的最远位置（i + nums[i]）
            maxPos = max(maxPos, i + nums[i]);
        }
        // 成功遍历完整个数组，说明可以到达最后一个位置
        return true;
    }
};

