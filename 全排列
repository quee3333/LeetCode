思路:1. 使用回溯法，通过深度优先搜索（DFS）生成所有排列。
 2. 使用一个布尔数组 `used` 来标记哪些数字已经被使用过。
 3. 使用一个数组 `combine` 来记录当前的排列。
#include <vector>
#include <functional> // 用于 std::function

class Solution {
public:
    std::vector<std::vector<int>> permute(std::vector<int>& nums) {
        std::vector<std::vector<int>> ans;
        std::vector<bool> used(nums.size(), false); // 记录元素使用状态
        std::vector<int> current;                   // 当前排列组合
        
        // 使用 lambda 表达式定义 DFS 函数
        std::function<void()> dfs = [&]() {
            if (current.size() == nums.size()) {
                ans.push_back(current); // 找到一个完整排列
                return;
            }
            
            for (int i = 0; i < nums.size(); ++i) {
                if (used[i]) continue;  // 跳过已用元素
                
                // 递归前更新状态
                used[i] = true;
                current.push_back(nums[i]);
                
                dfs();  // 递归探索
                
                // 回溯：恢复状态
                current.pop_back();
                used[i] = false;
            }
        };
        
        dfs(); // 启动深度优先搜索
        return ans;
    }
};

复杂度分析
时间复杂度：O(n * n!)，生成n!个排列，每个排列需要O(n)时间复制

空间复杂度：O(n)，递归栈深度最大为n，辅助空间used/current占用O(n)
