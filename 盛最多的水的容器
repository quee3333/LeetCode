思路：使用双指针，一个指向开头，一个指向结尾。计算当前两个指针所构成的容器的容量，并与最大值比较。然后，移动高度较小的那个指针（因为移动高度较大的指针不会使容量增大，而移动高度较小的指针则有可能在下一次遇到更高的高度，从而可能增大容量）。
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;          // 存储最大容量结果
        int l = 0;            // 左指针（起始位置0）
        int r = height.size() - 1;  // 右指针（起始位置末尾）
        
        while (l < r) {       // 双指针未相遇时循环
            int h = min(height[l], height[r]);  // 关键1：取当前两指针的较小高度
            ans = max(ans, h * (r - l));       // 关键2：计算当前容量并更新最大值
            
            if (height[l] < height[r]) // 关键3：总是移动较矮一端的指针
                l++;        // 左指针右移（试图找到更高左边界）
            else
                r--;        // 右指针左移（试图找到更高右边界）
        }
        return ans;  // 返回历史最大容量
    }
};
